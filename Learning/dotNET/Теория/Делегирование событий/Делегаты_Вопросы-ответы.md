### Делегаты

1. **Что такое делегат в C#?**  
    Делегат — это тип, представляющий метод с определённой сигнатурой.
    
2. **Как объявить делегат?**  
    `public delegate void MyDelegate(string message);`
    
3. **Чем делегаты отличаются от указателей на функции в C++?**  
    Делегаты безопасны для типов, поддерживают мультикаст и являются объектами первого класса.
    
4. **Что такое мультикаст-делегат?**  
    Делегат, который может ссылаться на несколько методов.
    
5. **Как добавить методы к делегату?**  
    Используя оператор `+=`, например: `myDelegate += MethodName;`.
    
6. **Как удалить метод из делегата?**  
    Используя оператор `-=`, например: `myDelegate -= MethodName;`.
    
7. **Могут ли делегаты возвращать значения?**  
    Да, делегаты могут возвращать значения, если их сигнатура это предусматривает.
    
8. **Что произойдет, если в мультикаст-делегате один из методов выбросит исключение?**  
    Выполнение прекратится, и исключение будет выброшено.
    
9. **Какой делегат используется по умолчанию для обратных вызовов?**  
    Делегат `Action`, если метод ничего не возвращает, или `Func<T>` для возвращающих значений.
    
10. **Какие ограничения накладываются на сигнатуру метода, связанного с делегатом?**  
    Метод должен соответствовать сигнатуре делегата.
    
11. **Какие делегаты являются встроенными в .NET Framework?**  
    `Action`, `Func<T>`, `Predicate<T>` — это основные делегаты, встроенные в .NET.
    
12. **Что такое обобщённый делегат?**  
    Делегат, который может работать с разными типами данных, например, `Func<T, TResult>` или `Action<T>`.
    
13. **Можно ли передать делегат как параметр метода?**  
    Да, делегат может быть параметром метода. Например:  
    `void ExecuteDelegate(Action action) { action(); }`
    
14. **Чем отличаются `Func<T>` и `Action<T>`?**  
    `Func<T>` возвращает значение, а `Action<T>` не возвращает (возвращает `void`).
    
15. **Что такое `Predicate<T>` и как он используется?**  
    Это делегат, который принимает один параметр и возвращает `bool`. Например, для фильтрации в методе `List<T>.Find`.
    
16. **Можно ли объединять делегаты с разной сигнатурой?**  
    Нет, делегаты должны иметь одинаковую сигнатуру для объединения.
    
17. **Как проверить, что делегат не ссылается на методы перед вызовом?**  
    Проверить на `null`: `if (myDelegate != null) myDelegate.Invoke();` или использовать безопасный вызов `myDelegate?.Invoke();`.
    
18. **Как работают асинхронные делегаты?**  
    Делегаты могут быть вызваны асинхронно с использованием метода `BeginInvoke` и `EndInvoke` (устарело) или с использованием `Task` и `async`.
    
19. **Что такое комбинация методов в делегате?**  
    Это список методов, которые вызываются последовательно, если делегат является мультикастом.
    
20. **Можно ли сравнивать два делегата?**  
    Да, два делегата можно сравнивать, если они имеют одинаковую сигнатуру и ссылаются на один и тот же метод в одном и том же объекте (если метод нестатический).
     

### Лямбда-выражения

1. **Что такое лямбда-выражение?**  
    Анонимный метод, представленный с использованием оператора =>.
    
2. **Чем лямбда-выражения отличаются от анонимных методов?**  
    Лямбда-выражения более лаконичны и поддерживают замыкания.
    
3. **Как объявить лямбда-выражение?**  
    Например: `(int x, int y) => x + y`.
    
4. **Можно ли использовать лямбды с несколькими строками кода?**  
    Да, используя фигурные скобки:  
    `(x, y) => { var sum = x + y; return sum; }`.
    
5. **Могут ли лямбда-выражения быть типизированными?**  
    Да, их тип определяется компилятором или явно задаётся делегатом.
    
6. **Что такое замыкание?**  
    Замыкание — это доступ к локальным переменным из внешнего контекста.
    
7. **Как лямбда-выражения связаны с делегатами?**  
    Лямбда-выражения компилируются как экземпляры делегатов.
    
8. **Можно ли использовать лямбда-выражения с LINQ?**  
    Да, они широко используются в LINQ для фильтрации, проекций и других операций.
    
9. **Какие ограничения есть у лямбда-выражений?**  
    Они не могут содержать объявления новых методов и классов.
    
10. **Какова разница между лямбдами и методами расширения?**  
    Методы расширения — это обычные методы, а лямбда — это выражения, компилируемые в делегаты.
    

### События

1. **Что такое событие в C#?**  
    Механизм уведомления объектов о произошедших действиях.
    
2. **Как объявить событие?**  
    `public event EventHandler MyEvent;`
    
3. **Чем событие отличается от делегата?**  
    Событие предоставляет ограниченный доступ к вызову делегата (только `+=` и `-=`).
    
4. **Что такое EventHandler?**  
    Предопределённый делегат для событий с аргументами.
    
5. **Как вызвать событие?**  
    Проверить на `null` и вызвать: `MyEvent?.Invoke(this, EventArgs.Empty);`.
    
6. **Как создать событие с кастомными аргументами?**  
    Создать класс, наследуемый от `EventArgs`, и использовать его в делегате события.
    
7. **Можно ли использовать лямбды в обработчиках событий?**  
    Да, например: `myEvent += (sender, e) => Console.WriteLine("Event triggered");`.
    
8. **Что такое подписчик на событие?**  
    Метод, который привязывается к событию и вызывается при его вызове.
    
9. **Что произойдёт, если событие не будет отписано?**  
    Возможна утечка памяти из-за удержания ссылки на объект.
    
10. **Какова практика управления событиями для предотвращения утечек памяти?**  
    Использовать слабые ссылки или отписываться от событий вручную.
    
11. **Какая основная цель использования событий?**  
    Уведомление подписчиков о наступлении какого-либо действия или изменения состояния.
    
12. **Какие модификаторы доступа используются для событий?**  
    События обычно объявляются с модификаторами `public`, `protected`, или `private`, но сами подписки (`+=` и `-=`) ограничиваются доступом, определённым модификатором.
    
13. **Как использовать события с несколькими подписчиками?**  
    Все подписчики вызываются последовательно в порядке их подписки.
    
14. **Можно ли объявить событие с кастомным делегатом?**  
    Да, например:
    
    ```csharp
    public delegate void MyCustomDelegate(string message);  
    public event MyCustomDelegate MyEvent;
    ```
    
15. **Как защитить событие от непреднамеренного вызова из внешнего кода?**  
    Событие может быть вызвано только внутри того класса, где оно объявлено.
    
16. **Что такое синхронизация событий?**  
    Убедиться, что событие вызывается в потоке, который его подписчики могут корректно обработать, например, в UI-потоке.
    
17. **Что произойдёт, если к событию никто не подписан, а оно вызывается?**  
    Ничего, если используется безопасный вызов `?.Invoke()`; иначе будет `NullReferenceException`.
    
18. **Можно ли использовать `+=` и `-=` для методов, не совпадающих с делегатом события?**  
    Нет, методы должны иметь такую же сигнатуру, как делегат, связанный с событием.
    
19. **Могут ли статические события быть подписаны на нестатические методы?**  
    Да, но подписчик должен быть объектом, чтобы можно было вызвать нестатический метод.
    
20. **Можно ли объявить событие как `static`?**  
    Да, события могут быть объявлены как статические, и все подписчики будут глобальными для всего приложения.
    
21. **Как правильно реализовать событие с дополнительной логикой?**  
    Использовать кастомный метод для добавления логики при подписке и отписке:
    
    ```csharp
    private EventHandler myEvent;  
    public event EventHandler MyEvent  
    {  
        add { myEvent += value; /* Доп. логика */ }  
        remove { myEvent -= value; /* Доп. логика */ }  
    }
    ```
    
22. **Что такое стандартная сигнатура событий в C#?**  
    События обычно используют `EventHandler` или `EventHandler<TEventArgs>`.
    
23. **Как организовать вызов события в безопасной многопоточной среде?**  
    Скопировать событие в локальную переменную и проверить её на `null` перед вызовом:
    
    ```csharp
    var handler = MyEvent;  
    handler?.Invoke(this, EventArgs.Empty);
    ```
    
24. **Можно ли передать событие как параметр метода?**  
    Нет, но можно передать делегат, связанный с событием.
    
25. **Как подписаться на событие в другом классе?**  
    Использовать экземпляр класса, где объявлено событие:
    
    ```csharp
    myObject.MyEvent += EventHandlerMethod;
    ```

---

### **Сигнатура** — это совокупность характеристик, которые определяют метод или делегат в C#. Она включает:

1. **Имя метода (или делегата)**.
    
    - Например, `Calculate` или `Action<int>`.
2. **Типы и порядок параметров**.
    
    - Это типы входных данных и их последовательность. Например:
        
        ```csharp
        void Calculate(int x, double y)  // Сигнатура: Calculate(int, double)
        ```
        
3. **Количество параметров**.
    
    - Например, метод с тремя параметрами отличается от метода с двумя.

Однако **возвращаемый тип** не является частью сигнатуры в C#. Это означает, что два метода с одинаковыми именем и параметрами, но разными возвращаемыми типами, не могут существовать в одном классе.

### Пример:

```csharp
void PrintMessage(string message);  // Сигнатура: PrintMessage(string)
int Sum(int x, int y);             // Сигнатура: Sum(int, int)
```

### В делегатах:

Сигнатура делегата определяет, каким методам можно присваивать этот делегат. Например:

```csharp
public delegate int MathOperation(int a, int b); // Сигнатура: (int, int) -> int
```

### Зачем нужна сигнатура?

- **Для компилятора**: помогает различать методы и определять, какой из них вызвать.
- **Для разработчика**: обеспечивает строгую типизацию, что делает код более понятным и безопасным.