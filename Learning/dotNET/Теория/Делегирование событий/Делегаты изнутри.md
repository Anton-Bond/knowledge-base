
Когда вы объявляете делегат, компилятор создает в коде изолированный класс для него, который будет наследником класса **MulticastDelegate**, а MulticastDelegate, в свою очередь, является наследником **Delegate** — базового класса для делегатов. Оба эти класса — системные, и вы не можете создавать собственных наследников, да я и не вижу необходимости в таком наследовании.
Классы-предки делегатов реализуют методы, необходимые событию для того, чтобы хранить список методов вызова. Когда подписчик подписывается на событие с помощью операции +=, то вызывается метод **Combine()**. Когда подписчик отписывается от события с помощью операции -=, вызывается метод **Remove()** класса Delegate.

Для каждого класса делегата, помимо наследуемых от MulticastDelegate и Delegate методов, система добавляет еще два специализированных метода: **BeginInvoke()** и **EndInvoke()**. Есть еще один очень важный метод: **Invoke()**, с которого мы и начнем рассмотрение делегата.

Метод Invoke() используется для генерации события синхронно. Синхронный вызов заставляет издателя ждать, пока подписчики не обработают событие, и только после этого издатель продолжает работу. До сих пор мы использовали именно синхронный вызов, хотя напрямую не вызывали метода Invoke(). Просто, если явно не указан метод, используется именно Invoke(). То есть синхронный вызов можно было бы сделать и так:
```C#
AgeChanged.Invoke(this, new EventArgs());
```

Методы BeginInvoke() и EndInvoke() позволяют генерировать событие асинхронно. В этом случае объект-издатель создает отдельный поток, внутри которого и происходит вызов методов подписчиков, а сам в это время продолжает выполняться параллельно в своем потоке. Это значит, что обработчики событий будут выполняться параллельно с работой основного объекта. Это хорошо, а иногда просто необходимо, но у асинхронного вызова есть свои нюансы.

Давайте вспомним пример, в котором издатель генерирует сообщение при попытке изменения фамилии:
```C#
LastNameChanged(this, changeevent);
if (changeevent.Canceled)
	return;
```

Что произойдет, если это событие будет сгенерировано асинхронно? Свойство Canceled, скорее всего, всегда будет равно false, потому что при генерации события не произойдет блокировки выполнения потока команд. Выполнение будет продолжаться параллельно с работой подписчиков. Так как проверка свойства Canceled происходит сразу после генерации события, я думаю, что ни один подписчик не успеет изменить свойство, работая параллельно с проверкой:
```C#
if (changeevent.Canceled)
	return;
```
Так что не пытайтесь получать какие-то данные от подписчиков, работая в асинхронном режиме, без синхронизации выполняемых потоков. Если нужен результат, проще использовать синхронный вызов. Асинхронный вызов лучше использовать только тогда, когда он действительно необходим и приносит пользу. Иначе лучше ограничиться синхронным вариантом.