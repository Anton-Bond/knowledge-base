

>**Делегат** -- это тип, определяющий полную сигнатуру метода события, которая включает в себя тип возвращаемого значения и список параметров. Например, вот так описан в C# делегат, который имеет два параметра:
	 `public delegate void EventHandler(Object sender, EventArgs e)`
 Делегат описывает метод, который ничего не возвращает, и его два параметра это:
	 `sender` — объект, который сгенерировал сообщение;
	 `e` — объект класса System.EventArgs.

Например, давайте добавим в наш класс Person свойство для хранения возраста, и при попытке изменить возраст будет вызываться событие.
Итак, с помощью ключевого слова event объявляем событие с именем AgeChanged класса EventHandler:
```C#
public event EventHandler AgeChanged;
```
Событие объявляется публичным (public), чтобы его могли отлавливать сторонние подписчики (подписчики любого класса).

Чтобы сгенерировать событие, нужно лишь вызвать его как простой метод, например:
```C#
AgeChanged(this, new EventArgs());
```

Такой вызов метода пройдет без ошибок только в том случае, если есть хотя бы один подписчик для нашего события. Если подписчиков нет, то переменная события AgeChanged будет равна нулю, и этот вызов сгенерирует исключительную ситуацию. Как поступить в таком случае? Нет, отлавливать исключительную ситуацию будет не очень хорошим решением. Намного лучше просто проверить событие на равенство нулю:
```C#
if (AgeChanged != null)
	AgeChanged(this, new EventArgs());
```

> **Note:** Событие может вызываться только в том классе, в котором оно объявлено. Это значит, что вы не можете сгенерировать событие `AgeChanged` из объекта класса `Zarplata`.

Теперь посмотрим, как может выглядеть свойство Age для хранения возраста:
```C#
int age = 0;
public int Age
{
	get { return age; }
	set
	{
		if (value < 0)
			throw new Exception("Возраст не может быть отрицательным");
			
		age = value;
		
		if (AgeChanged != null)
			AgeChanged(this, new EventArgs());
	}
}
```

Как теперь использовать событие в подписчике?
```C#
public partial class Form1 : Form
{
	Person p = new Person("Алексей", "Иванов");
	
	public Form1()
	{
		InitializeComponent();
		ageNumericUpDown.Value = p.Age;
		// регистрация события
		p.AgeChanged += new EventHandler(AgeChanged);
	}
	public void AgeChanged(Object sender, EventArgs args)
	{
		Person p = (Person)sender;
		MessageBox.Show("Возраст изменился на " + p.Age.ToString());
	}
	private void ageChangedButton_Click(object sender, EventArgs e)
	{
		p.Age = (int)ageNumericUpDown.Value;
	}
}
```

Самое интересное происходит в конструкторе: 
`p.AgeChanged += new EventHandler(AgeChanged);`. 
В событии регистрируются подписчики. Чтобы добавить свой объект в качестве получателя события, нужно выполнить операцию добавления к текущему значению нового экземпляра обработчика с помощью операции +=. Если нужно удалить обработчик события, то необходимо выполнить операцию -=.

Что мы прибавляем к событию? А прибавляем мы экземпляр делегата, которым является наше событие. Наше событие является делегатом EventHandler, а значит, мы должны добавить экземпляр EventHandler. Как создать экземпляр делегата? Такой вопрос еще интереснее, потому что в качестве параметра экземпляры делегатов получают имя метода, который должен вызываться в ответ на событие. Этот метод должен иметь точно такие же параметры, что и в описании делегата. В нашем случае мы передаем делегату EventHandler метод AgeChanged(). Именно этот метод станет вызываться каждый раз, когда объект Person будет генерировать событие.

---

