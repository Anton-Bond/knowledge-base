**Асинхронность** позволяет вынести отдельные задачи из основного потока в специальные асинхронные методы и при этом более экономно использовать потоки. Асинхронные методы выполняются в отдельных потоках. Однако при выполнении продолжительной операции поток асинхронного метода возвратится в пул потоков и будет использоваться для других задач. А когда продолжительная операция завершит свое выполнение, для асинхронного метода опять выделяется поток из пула потоков, и асинхронный метод продолжает свою работу.

Типы асинхронности в C#. Их три:
1. иветбайзасинопаттерн (по сути это события): **EAP (Event-based Asynchronous Pattern)** - устаревший
2.  **APM (Asynchronous Programming Model)** — основан на 2 методах. Метод BeginSmth возвращает интерфейс IAsyncResult. Метод EndSmth принимает IAsyncResult (если к моменту вызова EndSmth операция не завершена, поток блокируется) ((методы бегин сомсинг. енд сомсинг) - устаревший
3.  **TAP (Task-based Asynchronous Pattern)** - async/await

**Асинхронное программирование позволяет выполнять долгие или блокирующие операции (например, запросы к базе данных, сетевые вызовы или чтение файлов) без блокировки основного потока. Это улучшает отзывчивость приложений, особенно в графических интерфейсах или веб-серверах.**

Асинхронный метод обладает следующими признаками:

- В заголовке метода используется модификатор async
- Метод содержит одно или несколько выражений await    
- В качестве возвращаемого типа используется один из следующих:    
    - `void`        
    - `Task`        
    - `Task<T>`        
    - `ValueTask<T>`
- принято использовать суффикс **Async** в названиях методов

> **Note:** Однако асинхронный метод не может определять параметры с модификаторами **out**, **ref** и **in**.

### void
При использовании ключевого слова void асинхронный метод ничего не возвращает. Однако асинхронных void-методов следует избегать и следует использовать только там, где эти подобные методы представляют единственный возможный способ определения асинхронного метода.

> **Note:**  Следует учитывать, что если асинхронный метод имеет тип void, то в этом случае *исключение во вне не передается*, соответственно мы не сможем обработать исключение при вызове метода.

### Task
Возвращение объекта типа Task. Формально метод не использует оператор `return` для возвращения результата. Однако если в асинхронном методе выполняется в выражении await асинхронная операция, то мы можем возвращать из метода объект Task.

### [[Task T]] (generic Task)
Метод может возвращать некоторое значение. Тогда возвращаемое значение оборачивается в объект Task, а возвращаемым типом является `Task<T>`.

### [[ValueTask T]]
Использование типа `ValueTask<T>` во многом аналогично применению `Task<T>` за исключением некоторых различий в работе с памятью, поскольку ValueTask - структура, которая содержит большее количество полей. Поэтому применение ValueTask вместо Task приводит к копированию большего количества данных и соответственно создает некоторые дополнительные издержки.
Преимуществом ValueTask перед Task является то, что данный тип позволяет избежать дополнительных выделений памяти в хипе. Например, иногда требуется синхронно возвратить некоторое значение.
При необходимости также можно преобразовать ValueTask в объект Task с помощью метода **AsTask()**.

[[Объект задачи]]

### **[[Планировщик задач]] (`TaskScheduler`)**

Асинхронный код не обязательно выполняется на новых потоках. Вместо этого используется объект **`TaskScheduler`**, который управляет выполнением задач. Например:

- **В GUI-приложениях** (`WPF`, `WinForms`): задачи возвращаются на UI-поток.
- **В ASP.NET**: задачи выполняются на пуле потоков, без привязки к конкретному потоку.

### **[[Контекст синхронизации]] (`SynchronizationContext`)**

Контекст синхронизации управляет тем, где будет продолжено выполнение метода после `await`. Например:

- В WPF и WinForms — на UI-потоке.
- В ASP.NET Core контекста синхронизации нет, и задачи продолжаются на пуле потоков.

### [[Очереди и потоки]]

[[Внутреннее устройство асинхронного кода]]
## Последовательное и параллельное выполнение. Task.WhenAll и Task.WhenAny

**Task.WhenAll()** - принимает набор асинхронных задач и ожидает завершения всех этих задач.

**Task.WhenAny()** - завершает выполнение, когда завершается хотя бы одна задача.

### Получение результата

```C#
// определяем и запускаем задачи
var task1 = SquareAsync(4);
var task2 = SquareAsync(5);
var task3 = SquareAsync(6);
 
// ожидаем завершения всех задач
int[] results = await Task.WhenAll(task1, task2, task3);
// получаем результаты:
foreach (int result in results)
    Console.WriteLine(result);
 
async Task<int> SquareAsync(int n)
{
    await Task.Delay(1000);
    return n * n;
}
```

После завершения задачи ее результат можно получить стандартным образом через свойство **Result**:
```C#
// определяем и запускаем задачи
var task1 = SquareAsync(4);
var task2 = SquareAsync(5);
var task3 = SquareAsync(6);
 
await Task.WhenAll(task1, task2, task3);
// получаем результат задачи task2
Console.WriteLine($"task2 result: {task2.Result}"); // task2 result: 25
 
async Task<int> SquareAsync(int n)
{
    await Task.Delay(1000);
    return n * n;
}
```


## [[Машина состояний]]

## [[Асинхронные стримы]]
## [[INotifyCompletion]]

## [[Обработка ошибок в асинхронных методах]]

## [[Исключения]]

## [[Learning/dotNET/Теория/Aсинхронное программирование/Вопросы-ответы]]