**`TaskScheduler`** в C# — это компонент, который управляет выполнением задач (`Task`) в асинхронной модели. Он определяет, **где** и **как** будет выполнена задача: на каком потоке, в каком порядке и с какими ограничениями.

---

### **1. Зачем нужен TaskScheduler?**

- **Управление задачами:** TaskScheduler решает, какой поток или пул потоков будет использоваться для выполнения задачи.
- **Оптимизация ресурсов:** Он позволяет эффективно распределять задачи между потоками, избегая создания избыточных потоков.
- **Гибкость:** Позволяет создавать пользовательские планировщики для специализированных сценариев.

---

### **2. Как работает TaskScheduler?**

- **По умолчанию:** В большинстве случаев используется `ThreadPoolTaskScheduler`, который распределяет задачи в пул потоков.
- **Асинхронное выполнение:** Если задача создается без явного указания `TaskScheduler`, используется планировщик по умолчанию.
- **Контекст выполнения:** В GUI-приложениях (например, WPF, WinForms) задачи выполняются в контексте основного потока, чтобы избежать конфликтов с UI.

---

### **3. Основные типы TaskScheduler**

#### **a. `ThreadPoolTaskScheduler` (по умолчанию)**

- Это планировщик по умолчанию, использующий **пул потоков**.
- Оптимизирован для выполнения фоновых задач.
- Удобен для параллельного выполнения множества мелких задач.

**Пример:**

```csharp
Task.Run(() => Console.WriteLine("Task executed"));
```

#### **b. `SynchronizationContextTaskScheduler`**

- Используется в приложениях с UI (например, WPF, WinForms).
- Гарантирует, что задачи будут выполнены на основном (UI) потоке.
- Это полезно для обновления UI после завершения асинхронной операции.

**Пример:**

```csharp
public async Task UpdateUiAsync()
{
    await Task.Delay(1000); // Выполнение задачи в пуле потоков
    Console.WriteLine("UI updated on main thread");
}
```

#### **c. Пользовательские планировщики**

- Вы можете создавать собственные планировщики, наследуя `TaskScheduler`, чтобы управлять порядком выполнения задач или создавать дополнительные ограничения.

**Пример:**

```csharp
public class CustomTaskScheduler : TaskScheduler
{
    protected override IEnumerable<Task> GetScheduledTasks()
    {
        // Возвращает запланированные задачи
        return null;
    }

    protected override void QueueTask(Task task)
    {
        // Логика для добавления задачи в очередь
        ThreadPool.QueueUserWorkItem(_ => TryExecuteTask(task));
    }

    protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)
    {
        // Логика для выполнения задачи "на месте"
        return TryExecuteTask(task);
    }
}
```

---

### **4. Использование TaskScheduler**

#### **a. Планировщик по умолчанию**

Когда вы используете `Task.Run()` или `Task.Factory.StartNew()` без указания планировщика, используется `ThreadPoolTaskScheduler`.

#### **b. Указание планировщика**

Вы можете передать пользовательский планировщик через `TaskFactory`:

```csharp
var customScheduler = new CustomTaskScheduler();
var factory = new TaskFactory(customScheduler);

var task = factory.StartNew(() => Console.WriteLine("Custom Scheduler"));
task.Wait();
```

---

### **5. Пример работы TaskScheduler**

#### Пример: Выполнение задачи на UI-потоке

В WPF-приложении вы можете использовать `TaskScheduler.FromCurrentSynchronizationContext()`, чтобы вернуть управление на основной поток.

```csharp
public async Task UpdateLabelAsync(Label label)
{
    var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
    
    await Task.Run(() =>
    {
        // Долгая операция в фоновом потоке
        Thread.Sleep(2000);
    });

    // Обновление UI на главном потоке
    Task.Factory.StartNew(() =>
    {
        label.Content = "Task Completed!";
    }, CancellationToken.None, TaskCreationOptions.None, uiScheduler);
}
```

---

### **6. Важные моменты**

- **Контекст синхронизации и планировщик:**
    
    - Асинхронные методы (`async/await`) автоматически восстанавливают контекст выполнения (например, возвращаются на UI-поток).
    - Вы можете отключить это поведение с помощью `ConfigureAwait(false)`.
- **Планировщик задач в ASP.NET:**
    
    - В ASP.NET Core задачи выполняются в пуле потоков. Контекст синхронизации отсутствует, поэтому дополнительные действия для управления потоками не требуются.

---

### **7. Когда создавать пользовательский TaskScheduler?**

- **Контроль за потоками:** Если нужно управлять количеством потоков или создавать специализированные очереди задач.
- **Приоритет задач:** Когда требуется разное поведение для задач с разным приоритетом.
- **Диагностика:** Для отслеживания состояния задач или логирования их выполнения.

---

### **8. Диагностика TaskScheduler**

Для отладки и понимания работы `TaskScheduler` можно использовать:

- **`TaskScheduler.Default`** для получения планировщика по умолчанию.
- Логирование вызовов методов `QueueTask` и `TryExecuteTaskInline` в пользовательском планировщике.
