Когда в .NET-приложении выполняются несколько потоков одновременно, могут возникнуть проблемы, связанные с доступом к разделяемым ресурсам. Разберем ключевые аспекты конкурентности, основные проблемы и способы их решения.

---

## **1. Проблема конкурентности**

Конкурентность (concurrency) — это способность программы выполнять несколько операций одновременно, используя многопоточность, асинхронность и параллелизм.

**Основные проблемы:**

- **Race Condition (гонка потоков)**
- **Deadlock (взаимная блокировка потоков)**
- **Неатомарные операции (разрыв операций при многопоточности)**
- **Избыточное переключение контекста (переключение потоков = потери производительности)**

---

## **2. Race Condition (гонка потоков)**

**Race Condition** – ситуация, когда несколько потоков одновременно изменяют общий ресурс, что приводит к непредсказуемому поведению.

### **Пример Race Condition**

```csharp
class Counter
{
    private int _count = 0;

    public void Increment()
    {
        _count++; // НЕ атомарная операция! (чтение -> увеличение -> запись)
    }
}
```

Если два потока одновременно вызовут `Increment()`, возможен пропуск увеличения `_count`.

### **Решение Race Condition:**

- **Использование атомарных операций (`Interlocked`)**
- **Синхронизация потоков (`lock`, `Monitor`, `Mutex`)**

---

## **3. Синхронизация потоков**

Чтобы избежать Race Condition, нужно контролировать доступ потоков к разделяемым ресурсам.

### **1. `lock` (простая блокировка)**

```csharp
private object _lock = new();

public void Increment()
{
    lock (_lock) 
    {
        _count++;
    }
}
```

**Плюсы:** Простота использования.  
**Минусы:** Может привести к дэдлоку.

---

### **2. `Monitor` (расширенный контроль)**

```csharp
if (Monitor.TryEnter(_lock))
{
    try
    {
        _count++;
    }
    finally
    {
        Monitor.Exit(_lock);
    }
}
```

**Плюсы:** Позволяет проверять, удалось ли получить блокировку.  
**Минусы:** Сложнее в использовании, чем `lock`.

---

### **3. `Interlocked` (атомарные операции)**

`Interlocked` выполняет операции на переменных атомарно, избегая проблем гонки потоков.

```csharp
Interlocked.Increment(ref _count);  // _count += 1 атомарно
Interlocked.Decrement(ref _count);  // _count -= 1 атомарно
Interlocked.Add(ref _count, 5);     // _count += 5 атомарно
```

**Плюсы:** Высокая производительность, нет блокировок.  
**Минусы:** Работает только с примитивными типами (`int`, `long`).

---

## **4. Deadlock (взаимная блокировка потоков)**

Deadlock возникает, когда два или более потока ждут друг друга, блокируя общий ресурс.

### **Пример Deadlock**

```csharp
private object _lock1 = new();
private object _lock2 = new();

public void DeadlockMethod1()
{
    lock (_lock1)
    {
        Thread.Sleep(100); // Имитируем задержку
        lock (_lock2)
        {
            Console.WriteLine("Method1 завершился.");
        }
    }
}

public void DeadlockMethod2()
{
    lock (_lock2)
    {
        Thread.Sleep(100);
        lock (_lock1)
        {
            Console.WriteLine("Method2 завершился.");
        }
    }
}
```

Здесь `Method1` блокирует `_lock1`, а `Method2` — `_lock2`, что приводит к взаимной блокировке.

### **Способы избежать Deadlock:**

1. **Всегда блокировать ресурсы в одном и том же порядке!**
2. **Использовать `Monitor.TryEnter()` вместо `lock`**
3. **Переходить на асинхронные методы (`async/await`)**

---

## **5. `ConfigureAwait(false)` – что это?**

По умолчанию `await` продолжает выполнение кода в том же потоке (например, в UI-потоке WPF/WinForms).

```csharp
await Task.Delay(1000);
```

Если вызвать этот код в UI-приложении, выполнение после `await` продолжится в главном UI-потоке.

### **Проблема:**

Когда выполняется асинхронный код в ASP.NET Core или консольном приложении, нам **не нужно** возвращаться в тот же поток.

### **Решение:** `ConfigureAwait(false)`

```csharp
await Task.Delay(1000).ConfigureAwait(false);
```

**Что происходит?**

- Код после `await` продолжает выполнение в **первом доступном потоке**, а не в исходном.
- Это снижает накладные расходы переключения контекста.

**Где использовать `ConfigureAwait(false)`?**  
✔ В ASP.NET Core и сервисах (серверных приложениях).  
❌ НЕ использовать в WPF и WinForms (UI-поток будет потерян).

---

### **Заключение**

- **Конкурентность** важна для быстродействия, но несет риски (гонка потоков, deadlocks).
- **Race Condition** решается через `lock`, `Monitor`, `Interlocked`.
- **Deadlocks** можно избежать, блокируя ресурсы в одном порядке и используя `Monitor.TryEnter()`.
- **`ConfigureAwait(false)`** позволяет выполнять код без привязки к потоку, снижая накладные расходы.

**При подготовке к интервью стоит знать:**  
✅ Как избежать гонки потоков  
✅ Различия между `lock`, `Monitor`, `Mutex`, `Semaphore`  
✅ Что делает `Interlocked`  
✅ Причины deadlock'ов и их предотвращение  
✅ `ConfigureAwait(false)` и его влияние на производительность

