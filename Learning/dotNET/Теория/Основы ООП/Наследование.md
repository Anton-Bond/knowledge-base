Inheritance

**Возможность создавать новые классы на основе существующих (базовых).**

- Использование ключевого слова `:`.
- Базовый класс может предоставлять методы и свойства, которые наследуются производным классом.

```C#
public class Animal
{
    public string Name { get; set; }

    public void Eat()
    {
        Console.WriteLine($"{Name} is eating.");
    }
}

public class Dog : Animal
{
    public void Bark()
    {
        Console.WriteLine($"{Name} is barking.");
    }
}
```

Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:

- Не поддерживается множественное наследование, класс может наследоваться только от одного класса.
    
- При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа к производному классу должен быть таким же, как и у базового класса, или более строгим. То есть, если базовый класс у нас имеет тип доступа internal, то производный класс может иметь тип доступа internal или private, но не public.
    
    Однако следует также учитывать, что если базовый и производный класс находятся в разных сборках (проектах), то в этом случае производый класс может наследовать только от класса, который имеет модификатор public.
    
- Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы. Например, следующий класс не допускает создание наследников:
    
    sealed class Admin
    {
    }
    
- Нельзя унаследовать класс от статического класса.

### Ключевое слово base


```C#
class Person
{
    public string Name { get; set;}
    public Person(string name)
    {
        Name = name;
    }
    public void Print()
    {
        Console.WriteLine(Name);
    }
}
 
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company)
        : base(name)
    {
        Company = company;
    }
}
```

С помощью ключевого слова base мы можем обратиться к базовому классу. В нашем случае в конструкторе класса Employee нам надо установить имя и компанию. Но имя мы передаем на установку в конструктор базового класса, то есть в конструктор класса Person, с помощью выражения `base(name)`.

Те методы и свойства, которые мы хотим сделать доступными для переопределения, в базовом классе помечается модификатором **virtual**. А чтобы переопределить метод в классе-наследнике, этот метод определяется с модификатором **override**.

```C#
class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public virtual void Print()
    {
        Console.WriteLine(Name);
    }
}

class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company)
        : base(name)
    {
        Company = company;
    }
    public override void Print()
    {
        Console.WriteLine($"{Name} работает в {Company}");
    }
}
```

**Запрет переопределения методов**

Также можно запретить переопределение методов и свойств. В этом случае их надо объявлять с модификатором **sealed:**
```C#
class Employee : Person
{
    public string Company { get; set; }
  
    public Employee(string name, string company)
                : base(name)
    {
        Company = company;
    }
 
    public override sealed void Print()
    {
        Console.WriteLine($"{Name} работает в {Company}");
    }
}
```
При создании методов с модификатором sealed надо учитывать, что **sealed применяется в паре с override**, то есть только в переопределяемых методах.

## [[Скрытие методов и свойств]]



---
#### Вопросы:

1. Что такое наследование?  
    **Ответ:** Это механизм, позволяющий создавать новый класс на основе существующего.
    
2. Что такое базовый класс?  
    **Ответ:** Это класс, от которого наследуется другой класс.
    
3. Какие ключевые слова используются для наследования в C#?  
    **Ответ:** `:` для указания базового класса.
    
4. Можно ли наследовать несколько классов?  
    **Ответ:** Нет, но можно реализовать несколько интерфейсов.
    
5. Что означает ключевое слово `base`?  
    **Ответ:** Оно используется для обращения к членам базового класса.
    
6. Можно ли изменить модификатор доступа у метода базового класса?  
    **Ответ:** Нет, но можно переопределить его с помощью `override`.
    
7. Что произойдёт, если базовый класс изменится?  
    **Ответ:** Производные классы автоматически унаследуют изменения, если они не переопределяют методы.
    
8. Можно ли запретить наследование?  
    **Ответ:** Да, с помощью ключевого слова `sealed`.
    
9. Что такое множественное наследование?  
    **Ответ:** В C# классы не поддерживают множественное наследование, но интерфейсы — да.
    
10. Чем отличается наследование от композиции?  
    **Ответ:** Наследование создаёт иерархию классов, а композиция — ассоциацию через объекты.
    
11. Можно ли наследовать статический класс?  
    **Ответ:** Нет, статические классы нельзя наследовать.
    
12. Как вызвать конструктор базового класса?  
    **Ответ:** С помощью ключевого слова `base` в конструкторе производного класса.
    
13. Что означает ключевое слово `new` в наследовании?  
    **Ответ:** Оно скрывает метод базового класса.
    
14. Можно ли наследовать конструкторы?  
    **Ответ:** Нет, но можно вызывать их через `base`.
    
15. Какие преимущества наследования?  
    **Ответ:** Повторное использование кода и упрощение иерархии.
    
16. Как защитить метод от переопределения?  
    **Ответ:** С помощью ключевого слова `sealed`.
    
17. Что произойдёт, если удалить базовый класс?  
    **Ответ:** Производные классы станут некорректными.
    
18. Что такое "подстановочный объект" (substitution)?  
    **Ответ:** Использование объекта производного класса там, где ожидается объект базового.
    
19. Как влияет наследование на полиморфизм?  
    **Ответ:** Оно позволяет реализовать рантаймовый полиморфизм.
    
20. Как избежать проблем с "хрупкой базой"?  
    **Ответ:** Использовать композицию вместо наследования, где это возможно.
