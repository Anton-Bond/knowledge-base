Паттерны проектирования (Design Patterns) — это проверенные решения типичных задач проектирования программного обеспечения. Они не являются готовым кодом, а представляют собой шаблоны, которые можно адаптировать к конкретным ситуациям.

#### **Для чего они важны?**

Использование паттернов проектирования помогает:

- **Повысить читаемость кода** – код становится более понятным и структурированным.
- **Обеспечить гибкость** – код легко расширяется и модифицируется без серьезных изменений.
- **Снизить сложность кода** – паттерны помогают разбить сложные задачи на более простые и удобные для понимания части.
- **Упростить поддержку и масштабируемость** – код легче поддерживать и адаптировать к изменяющимся требованиям.
- **Соблюдать принципы [[SOLID]]** – паттерны помогают придерживаться лучших практик проектирования.

#### **Основная задача паттернов проектирования**

Основная цель паттернов — улучшить архитектуру приложения, сделать код более удобным, понятным и повторно используемым.

---

### **Три группы паттернов проектирования**

#### **1. Порождающие (Creational Patterns)**

Отвечают за создание объектов, снижая зависимость кода от конкретных классов.

- **Singleton (Одиночка)** – гарантирует, что у класса будет только один экземпляр.
- **Factory Method (Фабричный метод)** – определяет интерфейс для создания объектов, но оставляет выбор подклассам.
- **Abstract Factory (Абстрактная фабрика)** – создает семейства взаимосвязанных объектов.
- **Builder (Строитель)** – разделяет процесс создания сложного объекта от его представления.
- **Prototype (Прототип)** – создает новые объекты путем копирования существующих.

#### **2. Структурные (Structural Patterns)**

Отвечают за организацию классов и объектов, помогая строить гибкую архитектуру.

- **Adapter (Адаптер)** – позволяет объектам с несовместимыми интерфейсами взаимодействовать друг с другом.
- **Bridge (Мост)** – разделяет абстракцию и реализацию, позволяя изменять их независимо.
- **Composite (Компоновщик)** – позволяет сгруппировать объекты в древовидную структуру.
- **Decorator (Декоратор)** – динамически расширяет функциональность объекта.
- **Facade (Фасад)** – предоставляет упрощенный интерфейс к сложной системе.
- **Flyweight (Приспособленец)** – уменьшает использование памяти за счет повторного использования объектов.
- **Proxy (Заместитель)** – контролирует доступ к объекту, например, для ленивой инициализации.

#### **3. Поведенческие (Behavioral Patterns)**

Определяют способы взаимодействия объектов и распределения обязанностей между ними.

- **Observer (Наблюдатель)** – подписчики автоматически получают уведомления о изменениях объекта.
- **Event Aggregator (Агрегатор событий)** – упрощает передачу событий между различными частями системы.
- **Command (Команда)** – превращает запросы в объекты, позволяя параметризовать их.
- **Chain of Responsibility (Цепочка обязанностей)** – передает запрос по цепочке обработчиков.
- **Strategy (Стратегия)** – позволяет динамически изменять алгоритм выполнения задачи.
- **State (Состояние)** – изменяет поведение объекта в зависимости от его состояния.
- **Mediator (Посредник)** – управляет взаимодействием между объектами, снижая их связанность.

---

### **Плюсы и минусы использования паттернов проектирования**

#### ✅ **Плюсы**

- Улучшают архитектуру проекта.
- Повышают удобство сопровождения и расширяемость кода.
- Способствуют повторному использованию решений.
- Упрощают тестирование кода.

#### ❌ **Минусы**

- Усложняют проект, если используются без необходимости.
- Требуют дополнительных усилий для понимания и внедрения.
- Иногда перегружают код излишними абстракциями.

---
