#### **1. Что такое паттерны проектирования?**

**Ответ:** Паттерны проектирования – это готовые решения часто встречающихся проблем в разработке ПО. Они помогают сделать код более читаемым, гибким и поддерживаемым.

#### **2. На какие группы делятся паттерны проектирования?**

**Ответ:**

- **Порождающие** (Creational) – отвечают за создание объектов. (Singleton, Factory Method, Abstract Factory, Builder, Prototype).
- **Структурные** (Structural) – определяют, как классы и объекты взаимодействуют между собой. (Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy).
- **Поведенческие** (Behavioral) – управляют взаимодействием между объектами. (Observer, Mediator, Strategy, State, Command, Chain of Responsibility, Visitor, Template Method, Memento, Interpreter).

---

### **Порождающие паттерны**

#### **3. Что такое Singleton? Где его применяют?**

**Ответ:** Singleton гарантирует, что в приложении существует только один экземпляр класса. Например, используется для логирования, управления конфигурацией, работы с кэшем и подключения к БД.

**Пример реализации в C#:**

```csharp
public sealed class Singleton
{
    private static readonly Singleton _instance = new Singleton();
    private Singleton() { }
    public static Singleton Instance => _instance;
}
```

---

#### **4. Чем отличается Factory Method от Abstract Factory?**

**Ответ:**

- **Factory Method** создает объекты одного типа (например, фабрика машин производит только автомобили).
- **Abstract Factory** создает семейства объектов (например, фабрика машин может производить разные части автомобиля – двигатель, кузов, колеса).

**Пример Factory Method:**

```csharp
public abstract class Car
{
    public abstract void Drive();
}

public class BMW : Car
{
    public override void Drive() => Console.WriteLine("Driving BMW");
}

public abstract class CarFactory
{
    public abstract Car CreateCar();
}

public class BMWFactory : CarFactory
{
    public override Car CreateCar() => new BMW();
}
```

---

#### **5. В чем разница между Builder и Factory?**

**Ответ:**

- **Factory** создает объект за один вызов метода.
- **Builder** используется для создания сложных объектов пошагово.

**Пример Builder:**

```csharp
public class Car
{
    public string Engine { get; set; }
    public string Color { get; set; }
}

public class CarBuilder
{
    private Car _car = new Car();

    public CarBuilder SetEngine(string engine)
    {
        _car.Engine = engine;
        return this;
    }

    public CarBuilder SetColor(string color)
    {
        _car.Color = color;
        return this;
    }

    public Car Build() => _car;
}

// Использование:
var car = new CarBuilder().SetEngine("V8").SetColor("Red").Build();
```

---

### **Структурные паттерны**

#### **6. Что делает паттерн Adapter?**

**Ответ:** Adapter преобразует интерфейс одного класса в интерфейс, который ожидает клиент. Например, если у нас есть новый формат данных, а старый код работает только со старым форматом, можно использовать адаптер.

**Пример:**

```csharp
public interface ITarget
{
    void Request();
}

public class Adaptee
{
    public void SpecificRequest() => Console.WriteLine("Работа метода Adaptee");
}

public class Adapter : ITarget
{
    private readonly Adaptee _adaptee = new Adaptee();

    public void Request() => _adaptee.SpecificRequest();
}
```

---

#### **7. В чем разница между Decorator и Proxy?**

**Ответ:**

- **Decorator** добавляет новую функциональность без изменения исходного класса.
- **Proxy** контролирует доступ к объекту (например, кэширование, управление доступом, удаленный вызов).

**Пример Decorator:**

```csharp
public interface ICoffee
{
    string GetDescription();
    double GetCost();
}

public class SimpleCoffee : ICoffee
{
    public string GetDescription() => "Простой кофе";
    public double GetCost() => 5.0;
}

public class MilkDecorator : ICoffee
{
    private ICoffee _coffee;
    public MilkDecorator(ICoffee coffee) => _coffee = coffee;
    public string GetDescription() => _coffee.GetDescription() + ", молоко";
    public double GetCost() => _coffee.GetCost() + 2.0;
}
```

---

### **Поведенческие паттерны**

#### **8. Чем отличается Observer от Mediator?**

**Ответ:**

- **Observer** – объект подписывается на уведомления от другого объекта.
- **Mediator** – посредник управляет взаимодействием между несколькими объектами, чтобы они не зависели друг от друга напрямую.

**Пример Observer:**

```csharp
public interface IObserver
{
    void Update(string message);
}

public class Subscriber : IObserver
{
    private string _name;
    public Subscriber(string name) => _name = name;
    public void Update(string message) => Console.WriteLine($"{_name} получил уведомление: {message}");
}

public class Publisher
{
    private List<IObserver> _subscribers = new List<IObserver>();
    public void Subscribe(IObserver observer) => _subscribers.Add(observer);
    public void Notify(string message) => _subscribers.ForEach(s => s.Update(message));
}
```

---

#### **9. Что делает паттерн Strategy?**

**Ответ:** Strategy позволяет менять поведение объекта во время выполнения. Например, если у нас есть разные способы оплаты (карта, наличные), мы можем менять стратегию оплаты без изменения основного кода.

**Пример:**

```csharp
public interface IPaymentStrategy
{
    void Pay(double amount);
}

public class CreditCardPayment : IPaymentStrategy
{
    public void Pay(double amount) => Console.WriteLine($"Оплата {amount} картой");
}

public class CashPayment : IPaymentStrategy
{
    public void Pay(double amount) => Console.WriteLine($"Оплата {amount} наличными");
}

public class PaymentContext
{
    private IPaymentStrategy _strategy;
    public PaymentContext(IPaymentStrategy strategy) => _strategy = strategy;
    public void ExecutePayment(double amount) => _strategy.Pay(amount);
}

// Использование:
var payment = new PaymentContext(new CreditCardPayment());
payment.ExecutePayment(100);
```

---

### **Дополнительные вопросы**

#### **10. Какие паттерны часто используются в ASP.NET Core?**

**Ответ:**

- **Dependency Injection (DI)** – внедрение зависимостей, используется для управления зависимостями классов.
- **Singleton, Factory** – используются для управления экземплярами сервисов.
- **Decorator** – применяется в middleware.
- **Observer** – используется в системе событий.

---
