**Коллекция пар "ключ-значение".**

**Особенности:**
- Уникальные ключи.
- Быстрый доступ к элементам по ключу.
- Используется класс `Dictionary<TKey, TValue>`.
- безопасная коллекция
- содержит методы
- не потокобезопасный

```C#
Dictionary<int, string> people = new Dictionary<int, string>();
var people = new Dictionary<int, string>()
{
    { 5, "Tom"},
    { 3, "Sam"},
    { 11, "Bob"}
};
var people = new Dictionary<int, string>()
{
    [5] = "Tom",
    [6] = "Sam",
    [7] = "Bob"
};

// KeyValuePair<TKey, TValue>
var mike = new KeyValuePair<int, string>(56, "Mike"); 
var employees = new List<KeyValuePair<int, string>>() { mike};
var people = new Dictionary<int, string>(employees);
```

**Перебор словаря**
```C#
// 1
foreach(var person in people)
{
    Console.WriteLine($"key: {person.Key}  value: {person.Value}");
}
// 2
foreach (var (key, val) in people)  // раскладываем объект на свойства
{
    Console.WriteLine($"key: {key}  value: {val}");
}
```

---
### **Коллизии в словарях** — это ситуация, когда разные ключи в хэш-таблице имеют одинаковое хэш-значение. Это может произойти, потому что хэш-функция преобразует ключи в ограниченный диапазон значений, а разные ключи могут давать одинаковый результат.

#### **Как работают словари в C#:**

1. **Хэширование:** Ключ проходит через хэш-функцию, которая определяет его место в хэш-таблице.
2. **Коллизия:** Если два разных ключа дают одинаковое хэш-значение, они пытаются занять одну и ту же "ячейку" в таблице.

#### **Методы разрешения коллизий:**

1. **Связывание (Chaining):**  
    Коллизии решаются с помощью связного списка или другой структуры, где все ключи с одинаковым хэшом хранятся в одной ячейке.
    
    - Используется в `Dictionary<TKey, TValue>`.
2. **Открытая адресация (Open Addressing):**  
    При коллизии система ищет следующую свободную ячейку.
    
#### **Пример:**

```csharp
var dictionary = new Dictionary<int, string>();
dictionary.Add(1, "Value1");
dictionary.Add(17, "Value2"); // Допустим, 1 и 17 дают одинаковый хэш.
```

Значения `Value1` и `Value2` будут храниться в одной ячейке через механизм связывания.
#### **Влияние коллизий:**

- **Снижение производительности:**  
    Большое количество коллизий увеличивает время поиска.
- **Выбор хорошей хэш-функции:**  
    Использование качественных хэш-функций минимизирует вероятность коллизий.

**Важно:** В C# `Dictionary<TKey, TValue>` справляется с коллизиями эффективно, так что обычно программисту не нужно беспокоиться об этом напрямую.

---
- **Вопрос:** Что произойдет, если добавить элемент с уже существующим ключом?  
    **Ответ:** Вы получите исключение `ArgumentException`.
    
- **Вопрос:** Как проверить наличие ключа?  
    **Ответ:** Используйте `ContainsKey`.
    
- **Вопрос:** Какой хэш-алгоритм используется в `Dictionary`?  
    **Ответ:** По умолчанию используется `GetHashCode` объекта.
    
- **Вопрос:** Как удалить элемент по ключу?  
    **Ответ:**    
    `dictionary.Remove(key);`
    
- **Вопрос:** Можно ли использовать `null` в качестве ключа?  
    **Ответ:** В `Dictionary` это запрещено, но разрешено в `Hashtable`.
    
- **Вопрос:** Как получить значение без риска исключения?  
    **Ответ:**    
    `dictionary.TryGetValue(key, out value);`
    
- **Вопрос:** Как перечислить элементы в словаре?  
    **Ответ:** Используйте `foreach`:    
    `foreach (var kvp in dictionary)`
    `{`
       `Console.WriteLine($"{kvp.Key}: {kvp.Value}");` 
    `}`
    
- **Вопрос:** Как отсортировать словарь по ключам?  
    **Ответ:** Используйте `SortedDictionary`.
    
- **Вопрос:** Чем отличается `Dictionary` от `ConcurrentDictionary`?  
    **Ответ:** `ConcurrentDictionary` потокобезопасен и оптимизирован для многопоточности.
    
- **Вопрос:** Что такое `IEqualityComparer`?  
    **Ответ:** Интерфейс для пользовательского сравнения ключей.