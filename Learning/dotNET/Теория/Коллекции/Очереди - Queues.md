**Структура данных "первым пришел — первым вышел" (FIFO).**

**Особенности:**
- Элементы добавляются в конец и извлекаются из начала.
- Используется класс `Queue<T>`.

```C#
Queue<string> people = new Queue<string>();
Queue<string> people = new Queue<string>(16); // указание емкости

// инициализировать очередь элементами из другой коллекции или массивом
var employees = new List<string> { "Tom", "Sam", "Bob" };
Queue<string> people = new Queue<string>(employees);
```

Для перебора очереди можно использовать стандартный цикл **foreach**.

Для получения количества элементов в очереди в классе определено свойство **Count**.


- **Вопрос:** Как работает метод `Dequeue`?  
    **Ответ:** Удаляет и возвращает первый элемент.
    
- **Вопрос:** Как проверить, есть ли элементы в очереди?  
    **Ответ:** Используйте свойство `Count` или метод `Any`.
    
- **Вопрос:** Что делает метод `Peek`?  
    **Ответ:** Возвращает первый элемент без его удаления.
    
- **Вопрос:** Можно ли итерировать очередь?  
    **Ответ:** Да, с помощью `foreach`, но элементы не удаляются.
    
- **Вопрос:** Как сделать очередь потокобезопасной?  
    **Ответ:** Используйте `ConcurrentQueue`.
    
- **Вопрос:** Что произойдет, если вызвать `Dequeue` на пустой очереди?  
    **Ответ:** Исключение `InvalidOperationException`.
    
- **Вопрос:** Как очистить очередь?  
    **Ответ:
    `queue.Clear();`
    
- **Вопрос:** Как преобразовать очередь в массив?  
    **Ответ:** Используйте `queue.ToArray()`.
    
- **Вопрос:** Чем отличается очередь от `PriorityQueue`?  
    **Ответ:** В `PriorityQueue` элементы обрабатываются на основе их приоритета.
    
- **Вопрос:** Как реализовать очередь на базе двух стеков?  
    **Ответ:** Храните элементы в двух стеках: один для добавления, другой для извлечения.