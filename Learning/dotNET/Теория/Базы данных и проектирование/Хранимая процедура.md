### **1. Что такое хранимая процедура?**

**Хранимая процедура (Stored Procedure)** — это предварительно скомпилированный SQL-код, хранящийся в базе данных. Она выполняется на сервере и может принимать параметры, возвращать результаты и выполнять сложные операции.

**Пример создания хранимой процедуры:**

```sql
CREATE PROCEDURE GetCustomersByCity  
    @City NVARCHAR(50)  
AS  
BEGIN  
    SELECT * FROM Customers WHERE City = @City;  
END;
```

**Вызов хранимой процедуры:**

```sql
EXEC GetCustomersByCity @City = 'Moscow';
```

---

### **2. Преимущества хранимых процедур**

✅ **1. Повышение производительности**

- Процедуры **скомпилированы** один раз и хранятся в базе, что снижает нагрузку на сервер.
- Выполняются быстрее, чем динамический SQL.

✅ **2. Повышенная безопасность**

- Доступ к данным можно контролировать, **не давая прав на сами таблицы**, а только на выполнение процедур.

✅ **3. Централизованная бизнес-логика**

- Логика обработки данных хранится в БД, а не в коде приложения.

✅ **4. Снижение сетевого трафика**

- Запросы передаются как одна команда (`EXEC`), а не длинные SQL-скрипты.

✅ **5. Повторное использование кода**

- Можно вызывать одну и ту же процедуру в разных частях приложения.

---

### **3. Недостатки хранимых процедур**

❌ **1. Сложность поддержки**

- Логика, написанная на SQL, сложнее в отладке и тестировании, чем C#-код в приложении.

❌ **2. Привязка к конкретной СУБД**

- Хранимые процедуры **зависят от синтаксиса SQL-сервера** (например, T-SQL в SQL Server не совместим с PL/pgSQL в PostgreSQL).

❌ **3. Ограниченные возможности ООП**

- В отличие от C# и .NET, в SQL нет классов и интерфейсов.

❌ **4. Не всегда быстрее ORM**

- При сложных запросах ORM (например, Entity Framework) может быть **более оптимизированным** за счёт кэширования и оптимизации.

---

### **4. Подводные камни хранимых процедур**

⚠ **1. Сложная отладка**

- Нельзя использовать традиционные инструменты отладки, как в C#.
- Можно только выводить `PRINT` или `SELECT` для диагностики.
- Пример отладки через `PRINT`:
    
    ```sql
    CREATE PROCEDURE DebugProcedure  
    AS  
    BEGIN  
        PRINT 'Процедура запущена';  
        SELECT * FROM Customers;  
        PRINT 'Процедура завершена';  
    END;
    ```
    
    Вызов:
    
    ```sql
    EXEC DebugProcedure;
    ```
    

⚠ **2. Трудности обновления**

- Изменение хранимых процедур **может требовать перезапуска сервера**, особенно если они используются в транзакциях.

⚠ **3. Проблемы с масштабированием**

- Хранимые процедуры нагружают сервер базы данных.
- В микросервисной архитектуре логика в БД противоречит принципам распределённых систем.

⚠ **4. План выполнения может устареть**

- SQL Server кэширует план выполнения процедуры. Если данные в таблицах изменились, старый план может стать неэффективным.
- Решение: **перекомпилировать процедуру** перед выполнением:
    
    ```sql
    EXEC sp_recompile 'ProcedureName';
    ```
    

⚠ **5. Использование динамического SQL может быть небезопасным**

- **Ошибка:** динамический SQL без параметров подвержен SQL-инъекциям:
    
    ```sql
    CREATE PROCEDURE GetUser(@Name NVARCHAR(50))  
    AS  
    BEGIN  
        DECLARE @sql NVARCHAR(MAX)  
        SET @sql = 'SELECT * FROM Users WHERE Name = ''' + @Name + ''''  
        EXEC (@sql)  
    END;
    ```
    
- **Правильный вариант:** использование `sp_executesql`:
    
    ```sql
    CREATE PROCEDURE GetUserSecure(@Name NVARCHAR(50))  
    AS  
    BEGIN  
        EXEC sp_executesql  
        N'SELECT * FROM Users WHERE Name = @Name',  
        N'@Name NVARCHAR(50)',  
        @Name  
    END;
    ```
    

---

### **Вывод**

✅ **Использовать хранимые процедуры, когда нужна высокая производительность, безопасность и повторное использование логики.**  
❌ **Не злоупотреблять ими для сложной бизнес-логики — лучше использовать C# и ORM.**
