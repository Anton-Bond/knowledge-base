### 1. **Индексы – что это?**

Индексы в базе данных – это структуры, ускоряющие поиск данных. Они работают аналогично оглавлению книги: вместо того чтобы просматривать все страницы (сканировать всю таблицу), индекс помогает быстро найти нужную запись.

**Пример без индекса:**

```sql
SELECT * FROM Customers WHERE LastName = 'Ivanov';
```

Без индекса SQL Server будет просматривать **все записи** в таблице (Full Table Scan).

**Пример с индексом:**

```sql
CREATE INDEX idx_lastname ON Customers(LastName);
```

Теперь при поиске по `LastName` будет использоваться индекс, что ускорит выполнение запроса.

---

### 2. **Типы индексов: кластеризованные и некластеризованные**

#### **Кластеризованный индекс (Clustered Index)**

- Определяет физический порядок хранения строк в таблице.
- В каждой таблице может быть **только один** кластеризованный индекс.
- По умолчанию создаётся на `PRIMARY KEY`, если явно не указано иное.

**Пример:**

```sql
CREATE CLUSTERED INDEX idx_orders ON Orders(OrderID);
```

Теперь данные в таблице `Orders` хранятся **в порядке OrderID**.

✅ **Плюсы**:

- Быстрый поиск по первичному ключу.
- Эффективен для диапазонных запросов (`BETWEEN`, `ORDER BY`).

❌ **Минусы**:

- При вставке новых записей **может потребоваться перестроение индекса**.
- Таблица занимает больше места.

---

#### **Некластеризованный индекс (Non-Clustered Index)**

- Не изменяет порядок хранения строк.
- В одной таблице может быть **несколько** некластеризованных индексов.
- Хранит указатели (RowID) на реальные строки в таблице. !!!!

**Пример:**

```sql
CREATE NONCLUSTERED INDEX idx_customer_name ON Customers(LastName, FirstName);
```

Этот индекс ускорит поиск по `LastName` и `FirstName`.

✅ **Плюсы**:

- Можно создавать **много индексов** для разных запросов.
- Улучшает производительность поиска по неключевым полям.

❌ **Минусы**:

- Дополнительные операции поиска (если индекс не покрывает запрос).
- Увеличивает размер базы данных.
- Может замедлять `INSERT`, `UPDATE`, `DELETE`, так как индексы надо обновлять.

---

### 3. **Подводные камни индексов**

1️⃣ **Увеличение размера базы данных**  
Каждый индекс создаёт **отдельную структуру данных**. Чем больше индексов – тем больше места они занимают.

2️⃣ **Замедление `INSERT`, `UPDATE`, `DELETE`**  
Каждое изменение в таблице требует обновления индексов. Чем больше индексов – тем медленнее вставка новых записей.

3️⃣ **Дефрагментация**  
При частых вставках и удалениях индексы могут фрагментироваться, что снижает их эффективность. Нужно периодически выполнять **перестроение индексов**:

```sql
ALTER INDEX idx_lastname ON Customers REBUILD;
```

4️⃣ **Избыточные индексы**  
Если создать слишком много индексов, это может привести к **лишним накладным расходам**. Нужно анализировать, какие индексы реально используются:

```sql
SELECT * FROM sys.dm_db_index_usage_stats;
```

5️⃣ **Выбор неправильного порядка столбцов в составном индексе**  
Например, индекс `(LastName, FirstName)` эффективен для:

```sql
SELECT * FROM Customers WHERE LastName = 'Ivanov' AND FirstName = 'Alex';
```

Но не для:

```sql
SELECT * FROM Customers WHERE FirstName = 'Alex';
```

Потому что сначала идёт сортировка по `LastName`.

6️⃣ **Индекс не всегда используется автоматически**  
Иногда SQL Server решает, что **сканирование таблицы быстрее**, чем использование индекса (например, если запрос возвращает слишком много данных).

---

еще есть full text index and uniq index

### **Вывод**

- **Кластеризованный индекс** – один на таблицу, задаёт порядок хранения.
- **Некластеризованные индексы** – можно создавать много, но они занимают место.
- **Индексы ускоряют SELECT, но замедляют INSERT/UPDATE/DELETE**.
- **Нужно анализировать индексы и удалять неиспользуемые**.
