
…Касательно именований переменных/функций: идентификатор должен быть коротким, и описывать своё содержимое… если это новая и полезная информация или он используется в большом scope (иначе предпочтительны конвенциональные сокращения).
Иначе он увеличивает код и отвлекает на себя внимание
Например, вот строчка кода: 
```javascript
db.list('cameras').subscribe(cameras => {this.cameras = cameras})
```
В этом коде одно и то же слово повторяется несколько раз подряд просто потому что, включая когда это не требуется
Причём во втором случае (аргумент лямбды) это название не содержит новой информации, потому что в контексте уже написано что данные берутся именно по камерам
А вот в варианте 
```javascript
db.list('cameras').subscribe(xs => {this.cameras = xs})
```
меньше тавтологии, и идентификатор xs приемлем т.к. данные о содержимом есть в контексте (более того, даже в случае если лямбду вынести во внешнюю функцию они на самом деле не важны, т.к. содержимое значения вообще никак не используется, оно всего лишь присваивается в поле; так что достаточно назвать функцию setCameras, что в любом случае следует сделать т.к. это название отражает её сущность… и да, даже признак коллекции – окончание s – не так уж важно по той же причине).
Или вот такой пример:
```javascript
db.list('cameras').subscribe(cameras => {
  cameras = cameras.reduce((cameras, camera) => {cameras[camera.type] = (cameras[camera.type] || 0) + 1;  return cameras}, {});
  console.log(cameras);
});
```
В этом случае слово «камера» появляется в большинстве идентификаторов… что есть дико печально и вообще ни разу не помогает с чтением кода
```javascript
db.list('cameras').subscribe(xs => {
  let counters = xs.map(x => x.type).reduce((o, k) => {o[k] = (o[k] || 0) + 1;  return o}, {});
  console.log(counters);
});
```
Внезапно, изменение идентификаторов и использование конвенциональных сокращений (в данном случае o это объект/словарь, а x это просто элемент xs) делает код более читабельным. Это допустимо, т.к. scope этих переменных очень мал, а краткость в именовании (и различие с внешними идентификаторами) концентрирует внимание читателя на сути происходящего (инкрементируем поле первого аргумента – словаря – взятое по значению второго – ключа); к тому же логика функции целиком абстрактна и ничто не мешает вынести её в утилиту общего пользования, ведь эта операция агностична контексту.
Конвенциональные сокращения (наиболее широко практикуемые в частности в Haskell, если слышал) обычно такие:
если содержимое переменной не важно, используем абстрактное именование (x, y, z); в случае функции единственного аргумента допустим анафоризм (т.е. местоимение – it; вариант с this в частности тебе должен быть знаком, в несколько ином контексте :slightly_smiling_face:)
если важно указать что это коллекция (используется групповая операция/перебор), дописываем **s** в конец (**x** может быть элементом **xs**, который в свою очередь может быть элементом xss; это можно использовать также с не-абстрактными именами)
если переменная имеет значение только как представитель конкретного типа, можно использовать сокращение по типу (*o/d/m/h для объектов/словарей/map'ов/хэшей в зависимости от языка, n/m для чисел, s для строк, c для отдельных символов и т.п.*)
опять же, если содержимое переменной принадлежит какое-то распространённой категории, может иметь смысл использовать контекстуальное сокращение (*i/j для индексов, k для ключей; в случае с обработкой графов встречается конвенция u для текущей вершины и v/w для перебираемой*)
собственно полные слова используются в случаях когда это осмысленно (когда для кода важно конкретное содержание, и оно не очевидно из контекста, либо когда scope идентификатора слишком большой – хотя для функций это нередко означает что неплохо бы поднять уровень языка, вынеся куски кода в именованные операции которые описывают соответствующие действия одним/парой слов)


…Да, контекст это как правило:
имя/назначение файла/класса (для глобальных функций и методов, в частности);
имя самой функции/метода (для именованных)
имя функции куда передаётся/значения куда помещается (для лямбд)
значения на которые применяется (в случае с .map таковым является коллекция на которой .map вызывается, в частности… точнее, элемент оной)



https://javascript.info/mixins
https://www.basefactor.com/global-state-with-react
https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500